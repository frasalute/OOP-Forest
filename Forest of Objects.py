# Forest of Objects
import numpy as np
import cv2 as cv
import random

# general parameters
width= 900
height= 600
n_trees=30
ground_level=height-100

#blank image
bg=np.zeros((height, width, 3), dtype=np.uint8)

"""""np.zeros() is a NumPy function that creates an array filled with zeros. 
((height, width, 3), dtype=np.uint8) is the argument passed to np.zeros(). It specifies the shape and data type of the array.
(height, width, 3): This part defines the shape of the array. It creates a 3-dimensional array with dimensions specified by the variables height and width. 
The 3 indicates that each element in the array will have three components (typically used for color channels in images).
dtype=np.uint8: This part specifies the data type of the array. np.uint8 stands for 8-bit unsigned integer, which means that each element in the array can
have values from 0 to 255. This data type is commonly used for images because it allows you to represent pixel values in the range from black (0) to white 
(255) in each color channel.So, the code creates a 3-dimensional NumPy array bg that can be used to represent an image with a specified height and width, 
where each pixel has three color channels (e.g., for representing RGB colors) and each channel is an 8-bit unsigned integer. Initially, all the values in 
this array will be set to 0, creating a black image. You can later modify the values in this array to represent the desired image."""""

# draw background
cv.rectangle(bg,(width,0),(0,ground_level),(255,225,95),-1)
cv.rectangle(bg,(width,ground_level),(0,height),(70,180,75 ), -1)

class Tree:
    def __init__(self,image):
        self.image=image
        self.height=int(np.random.choice(range(200,350),1))
        self.radius=50
        self.scale=np.random.choice(np.linspace(0.5,2.5,num=8),1)
        self.location=int(np.random.choice(range(900),1))

    def generate_colours(self):
        green =(0,random.randint(130,200), 0) #Red component (0): The intensity of the red color is set to 0, indicating no contribution of red to the final color.
        # Green component (random.randint(130,200)): The intensity of the green color is set to a random integer value generated by the randint function from the random module.
        # The generated value will be between 130 and 200, inclusive.
        # Blue component (0): The intensity of the blue color is set to 0, indicating no contribution of blue to the final color.

        light_green = (35, random.randint(200,250), 35)
        brown=random.choice([(2,30,85),(5,55,120),(0,70,140)]) #3 precise shades of brown
        return green, light_green, brown

    def draw(self):
        small_radius= int(self.radius*self.scale-20*self.scale)
        green, light_green, brown=self.generate_colours()

        # leafs shadows
        cv.circle(self.image, (self.location,ground_level-self.height),int(self.radius*self.scale), green, -1)
        cv.circle(self.image, (self.location-int(45*self.scale), ground_level - self.height+small_radius), small_radius, green, -1)
        cv.circle(self.image, (self.location + int(45*self.scale), ground_level - self.height + small_radius), small_radius, green, -1)
        #ground_level minus because you need to make height relative to the ground height.

        # trunk
        cv.line(self.image, (self.location, ground_level), (self.location, ground_level - self.height), brown,int(20 * self.scale))
        cv.line(self.image, (self.location, ground_level - self.height + int(75 * self.scale)),(self.location + int(45 * self.scale), ground_level - self.height + small_radius), brown, int(5 * self.scale))
        cv.line(self.image, (self.location, ground_level - self.height + int(75 * self.scale)),(self.location - int(45 * self.scale), ground_level - self.height + small_radius), brown, int(5 *self.scale))

        #leaf highlights
        cv.circle(self.image, (self.location, ground_level - self.height), int(self.radius * self.scale-10*self.scale), light_green, -1)
        cv.circle(self.image, (self.location - int(45 * self.scale), ground_level - self.height + small_radius),small_radius-int(10*self.scale), light_green, -1)
        cv.circle(self.image, (self.location + int(45 * self.scale), ground_level - self.height + small_radius),small_radius-int(10*self.scale), light_green, -1)

        cv.rectangle(bg, (width, ground_level), (0, height), (70, 180, 75), -1)
        return self.image


# display the image
for i in range(n_trees):
    image=Tree(bg).draw() #this is very precise because going from the first tree we separate them all the same number of pixels
    #so the key is in getting rid of the location parameter in the __init__ function
cv.imshow('forest of objects', image)

cv.waitKey(0)
cv.destroAllWindows()











